#!/usr/bin/env python3
#
# (C) 2018-2020 Ed Bueler

# Create PETSc binary files .vec,.is from ascii .msh mesh file generated by Gmsh.

# This script is based on the Gmsh ASCII format (version 4.1) documented at
#   http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format
# and the legacy format (version 2.2) at
#   http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format-version-2-_0028Legacy_0029

# example: put PETSc Vec with locations (node coordinates x,y) in meshes/trap.vec
# and PETSc ISs (e,bf,ns) in meshes/trap.is
#    $ make petscPyScripts
#    $ gmsh -2 meshes/trap.geo
#    $ ./msh2petsc.py meshes/trap.msh

import numpy as np
import sys

from meshes.format22 import read_nodes_22, read_elements_22
from meshes.format41 import read_entities_41, read_nodes_41, read_elements_41

# debug print
def dprint(debug,s):
    if debug:
        print(s)

# fail and exit with message
def fail(s):
    print('ERROR: %s ... stopping' % s)
    sys.exit(1)

def get_mesh_format(filename):
    MFread = False
    with open(filename, 'r') as mshfile:
        for line in mshfile:
            line = line.strip()  # remove leading and trailing whitespace
            if line: # only look at nonempty lines
                if line == '$MeshFormat':
                    assert (not MFread), '$MeshFormat repeated'
                    MFread = True
                elif MFread:
                    nums = line.split(' ')
                    gmshversion = nums[0]
                    assert (gmshversion in ['2.2','4.1']), \
                        'unknown Gmsh format version %s' % gmshversion
                    assert (nums[1:] == ['0','8']), 'unexpected MeshFormat data'
                    break
        return gmshversion

# this is the same format for 2.2 and 4.1
def read_physical_names(filename):
    PNread = False
    nPN = 0
    physical = {}   # empty dictionary
    with open(filename, 'r') as mshfile:
        for line in mshfile:
            line = line.strip()  # remove leading and trailing whitespace
            if line: # only look at nonempty lines
                if line == '$PhysicalNames':
                    PNread = True
                elif line == '$EndPhysicalNames':
                    assert (PNread), '$EndPhysicalNames before $PhysicalNames'
                    break
                elif PNread:
                    ls = line.split(' ')
                    if nPN == 0 and len(ls) == 1:
                        nPN = int(ls[0])
                    else:
                        assert (len(ls) == 3), 'expected three items on line'
                        dim = int(ls[0])
                        num = int(ls[1])
                        physical[ls[2].strip('"').lower()] = num
    assert (nPN == len(physical)), 'expected number of physical names does not equal number read'
    for key in ['dirichlet','neumann','interior']:
        assert (key in physical), 'no key "%s" in dictionary' % key
    return physical


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description= \
'''Converts .msh ASCII file from Gmsh into PETSc binary files with .vec
and .is extensions.  Reads both Gmsh file format version 2.2 (legacy) and 4.1.
Needs link to ${PETSC_DIR}/lib/petsc/bin/PetscBinaryIO.py.''')
    # required positional filename
    parser.add_argument('-v', default=False, action='store_true',
                        help='verbose output for debugging')
    parser.add_argument('inname', metavar='FILE',
                        help='input file name with .msh extension')
    args = parser.parse_args()

    import PetscBinaryIO

    if args.inname.split('.')[-1] == 'msh':
        outroot = '.'.join(args.inname.split('.')[:-1]) # strip .msh
    else:
        print('WARNING: expected .msh extension for input file')
    vecoutname = outroot + '.vec'
    isoutname = outroot + '.is'
    gmshversion = get_mesh_format(args.inname)
    print('  input file %s in Gmsh format v%s' % (args.inname,gmshversion))

    print('  reading physical names ...')
    phys = read_physical_names(args.inname)
    dprint(args.v,phys)

    if gmshversion == '4.1':
        print('  reading entities ...')
        tagmap = read_entities_41(args.inname)
        dprint(args.v,tagmap)

    print('  reading node coordinates ...')
    if gmshversion == '2.2':
        N,xy = read_nodes_22(args.inname)
    else:
        N,xy = read_nodes_41(args.inname)
    dprint(args.v,'N=%d' % N)
    dprint(args.v,xy)

    print('  writing N=%d node coordinates as PETSc Vec to %s ...' \
          % (N,vecoutname))
    petsc = PetscBinaryIO.PetscBinaryIO()
    petsc.writeBinaryFile(vecoutname,[xy.view(PetscBinaryIO.Vec),])

    print('  reading element tuples ...')
    if gmshversion == '2.2':
        e,bf,ns = read_elements_22(args.inname,N,phys)
    else:
        e,bf,ns = read_elements_41(args.inname,N,tagmap)
    assert (len(e) % 3 == 0), 'element index list length not 3 K'
    K = len(e) / 3
    dprint(args.v,e)
    assert (len(bf) == N), 'boundary flag list not length N'
    dprint(args.v,bf)
    assert (len(ns) % 2 == 0), 'Neumann segment index list length not 2 P'
    P = len(ns) / 2
    if (P == 0):
        print('WARNING: P=0 so writing a bogus negative-valued Neumann boundary segment')
        ns = np.array([-1,-1],dtype=int)
    dprint(args.v,ns)
    print('  writing K=%d elements, N=%d boundary flags, and P=%d Neumann segments' \
          % (K,N,P))
    print('    as PETSc IS to %s ...' % isoutname)
    IS = PetscBinaryIO.IS
    petsc.writeBinaryFile(isoutname,[e.view(IS),bf.view(IS),ns.view(IS)])

